{"version":3,"sources":["webpack:///./routes/remote_game.js"],"names":["RemoteGame","Component","constructor","props","super","boardClick","event","console","log","this","game","finished","nextPlayer","player","isEmpty","alert","controller","move","boardIndex","restart","newgame","route","state","connectedToPeer","connectedToPlayer","waiting","error","win","board","ttt","generateEmptyBoard","window","hostId","location","search","replace","RemoteGameController","O","on","setState","connectToHost","winIndexes","status","draw","X","xWin","oWin","renderConnecting","renderButtons","renderWaitingForPlayer","renderBoard","click","class","onclick","render"],"mappings":"6FAAA,+GAOe,MAAMA,UAAmBC,YACtCC,YAAaC,GACXC,MAAMD,GADY,KA0CpBE,WAAcC,IACZC,QAAQC,IAAI,aAAcF,EAAOG,KAAKC,MAClCD,KAAKC,KAAKC,UACVF,KAAKC,KAAKE,aAAeH,KAAKI,SAC7BP,EAAMQ,SAASC,MAAM,+BAE1BN,KAAKO,WAAWC,KAAKX,EAAMY,cAhDT,KAmDpBC,QAAWb,KACTG,KAAKO,WAAWG,WApDE,KAuDpBC,QAAWd,KACTe,YAAM,MArDNZ,KAAKa,MAAQ,CACXC,iBAAiB,EACjBC,mBAAmB,EACnBC,SAAS,EACTC,OAAO,EACPC,IAAK,GACLC,MAAOC,IAAIC,sBAGS,oBAAXC,SAEXtB,KAAKuB,OAASD,OAAOE,SAASC,OAAOC,QAAQ,IAAK,IAIlD1B,KAAKO,WAAa,IAAIoB,IAAqBP,IAAIQ,GAC/C5B,KAAKO,WAAWsB,GAAG,QAAQ,KACzB7B,KAAK8B,SAAS,CAAEhB,iBAAiB,IACjCd,KAAKO,WAAWwB,cAAc/B,KAAKuB,WAErCvB,KAAKO,WAAWsB,GAAG,aAAa,IAAM7B,KAAK8B,SAAS,CAAEf,mBAAmB,MACzEf,KAAKO,WAAWsB,GAAG,oBAAqB5B,IAEtCD,KAAK8B,SAAS,CACZd,QAFchB,KAAKC,KAAKE,aAAeH,KAAKI,OAG5Cc,IAAKjB,EAAK+B,WACVb,MAAOlB,EAAKkB,YAKR,aACR,OAAOnB,KAAKO,YAAcP,KAAKO,WAAWH,OAGpC,WACN,OAAOJ,KAAKO,YAAcP,KAAKO,WAAWN,KAoB5CgC,SACE,OAAIjC,KAAKC,MAAQD,KAAKC,KAAKC,SACrBF,KAAKC,KAAKiC,KAAa,MACtBlC,KAAKI,SAAWgB,IAAIe,GAAKnC,KAAKC,KAAKmC,MAAUpC,KAAKI,SAAWgB,IAAIQ,GAAK5B,KAAKC,KAAKoC,KAAc,UAC5F,WAEArC,KAAKa,MAAMG,QAAU,aAAe,eAI/CsB,mBACE,OACE,wBACE,sCACCtC,KAAKuC,iBAKZC,yBACE,OACE,wBACE,gDACCxC,KAAKuC,iBAKZE,cACE,MAAMtB,EAAQnB,KAAKa,MAAME,kBAAqB,YAAC,IAAD,CAAOG,IAAKlB,KAAKa,MAAMK,IAAKC,MAAOnB,KAAKa,MAAMM,MAAOuB,MAAO1C,KAAKJ,aAAkB,wBACjI,OACE,wBACE,8CACA,mBAAK+C,MAAM,iBACRxB,EACD,oBAAMwB,MAAM,UAAU3C,KAAKiC,WAE5BjC,KAAKuC,iBAKZA,gBACE,MAAM7B,EAAUV,KAAKC,MAAQD,KAAKC,KAAKC,SAAW,sBAAQ0C,QAAS5C,KAAKU,SAAtB,WAAkD,GACpG,OACE,qBACGA,EACD,sBAAQkC,QAAS5C,KAAKW,SAAtB,aAKNkC,OAAQnD,EAAOmB,GACb,OAAKA,EAAMC,gBACND,EAAME,kBACJf,KAAKyC,cADyBzC,KAAKwC,yBADPxC,KAAKsC","file":"route-remote_game.chunk.ea850.js","sourcesContent":["import { h, Component } from 'preact'\nimport { route } from 'preact-router'\n\nimport Board from '../components/board'\nimport ttt from '../lib/game'\nimport RemoteGameController from '../lib/remote_game_controller'\n\nexport default class RemoteGame extends Component {\n  constructor (props) {\n    super(props)\n\n    this.state = {\n      connectedToPeer: false,\n      connectedToPlayer: false,\n      waiting: true,\n      error: false,\n      win: [],\n      board: ttt.generateEmptyBoard()\n    }\n\n    if (typeof window === 'undefined') return\n\n    this.hostId = window.location.search.replace('?', '')\n\n    // TODO: what to do if there isn't a host id\n\n    this.controller = new RemoteGameController(ttt.O)\n    this.controller.on('open', () => {\n      this.setState({ connectedToPeer: true })\n      this.controller.connectToHost(this.hostId)\n    })\n    this.controller.on('connected', () => this.setState({ connectedToPlayer: true }))\n    this.controller.on('updatedGameState', (game) => {\n      const waiting = this.game.nextPlayer !== this.player\n      this.setState({\n        waiting,\n        win: game.winIndexes,\n        board: game.board\n      })\n    })\n  }\n\n  get player () {\n    return this.controller && this.controller.player\n  }\n\n  get game () {\n    return this.controller && this.controller.game\n  }\n\n  boardClick = (event) => {\n    console.log('BoardClick', event, this.game)\n    if (this.game.finished) return\n    if (this.game.nextPlayer !== this.player) return\n    if (!event.isEmpty) alert('This space is already taken')\n\n    this.controller.move(event.boardIndex)\n  }\n\n  restart = (event) => {\n    this.controller.restart()\n  }\n\n  newgame = (event) => {\n    route('/')\n  }\n\n  status () {\n    if (this.game && this.game.finished) {\n      if (this.game.draw) return 'Tie'\n      if ((this.player === ttt.X && this.game.xWin) || (this.player === ttt.O && this.game.oWin)) return 'You won'\n      return 'You lost'\n    } else {\n      return this.state.waiting ? 'Waiting...' : 'Your turn...'\n    }\n  }\n\n  renderConnecting () {\n    return (\n      <main>\n        <p>Connecting...</p>\n        {this.renderButtons()}\n      </main>\n    )\n  }\n\n  renderWaitingForPlayer () {\n    return (\n      <main>\n        <p>Connecting to player...</p>\n        {this.renderButtons()}\n      </main>\n    )\n  }\n\n  renderBoard () {\n    const board = this.state.connectedToPlayer ? (<Board win={this.state.win} board={this.state.board} click={this.boardClick} />) : <div />\n    return (\n      <main>\n        <p>You are playing as O.</p>\n        <div class='board-wrapper'>\n          {board}\n          <span class='status'>{this.status()}</span>\n        </div>\n        {this.renderButtons()}\n      </main>\n    )\n  }\n\n  renderButtons () {\n    const restart = this.game && this.game.finished ? <button onclick={this.restart}>Restart</button> : ''\n    return (\n      <p>\n        {restart}\n        <button onclick={this.newgame}>New Game</button>\n      </p>\n    )\n  }\n\n  render (props, state) {\n    if (!state.connectedToPeer) return this.renderConnecting()\n    if (!state.connectedToPlayer) return this.renderWaitingForPlayer()\n    return this.renderBoard()\n  }\n}\n"],"sourceRoot":""}