{"version":3,"sources":["webpack:///./routes/remote_game.js"],"names":["RemoteGame","props","boardClick","event","console","log","game","finished","nextPlayer","player","isEmpty","alert","controller","move","boardIndex","restart","newgame","route","state","connectedToPeer","connectedToPlayer","waiting","error","win","board","ttt","generateEmptyBoard","window","hostId","location","search","replace","RemoteGameController","O","on","setState","connectToHost","winIndexes","status","this","draw","X","xWin","oWin","renderConnecting","renderButtons","renderWaitingForPlayer","renderBoard","click","class","onclick","render","Component"],"mappings":"kXAOqBA,E,YACnB,WAAaC,GAAO,MAYlB,OAXA,cAAMA,IAAN,MAyCFC,WAAa,SAACC,GACZC,QAAQC,IAAI,aAAcF,EAAO,EAAKG,MAClC,EAAKA,KAAKC,UACV,EAAKD,KAAKE,aAAe,EAAKC,SAC7BN,EAAMO,SAASC,MAAM,+BAE1B,EAAKC,WAAWC,KAAKV,EAAMW,cAhDT,EAmDpBC,QAAU,WACR,EAAKH,WAAWG,WApDE,EAuDpBC,QAAU,WACRC,YAAM,MArDN,EAAKC,MAAQ,CACXC,iBAAiB,EACjBC,mBAAmB,EACnBC,SAAS,EACTC,OAAO,EACPC,IAAK,GACLC,MAAOC,IAAIC,sBAGS,oBAAXC,O,yHAAwB,KAEnC,EAAKC,OAASD,OAAOE,SAASC,OAAOC,QAAQ,IAAK,IAIlD,EAAKnB,WAAa,IAAIoB,IAAqBP,IAAIQ,GAC/C,EAAKrB,WAAWsB,GAAG,QAAQ,WACzB,EAAKC,SAAS,CAAEhB,iBAAiB,IACjC,EAAKP,WAAWwB,cAAc,EAAKR,WAErC,EAAKhB,WAAWsB,GAAG,aAAa,kBAAM,EAAKC,SAAS,CAAEf,mBAAmB,OACzE,EAAKR,WAAWsB,GAAG,oBAAoB,SAAC5B,GAEtC,EAAK6B,SAAS,CACZd,QAFc,EAAKf,KAAKE,aAAe,EAAKC,OAG5Cc,IAAKjB,EAAK+B,WACVb,MAAOlB,EAAKkB,WA7BE,G,gIA2DpBc,OAAA,WACE,OAAIC,KAAKjC,MAAQiC,KAAKjC,KAAKC,SACrBgC,KAAKjC,KAAKkC,KAAa,MACtBD,KAAK9B,SAAWgB,IAAIgB,GAAKF,KAAKjC,KAAKoC,MAAUH,KAAK9B,SAAWgB,IAAIQ,GAAKM,KAAKjC,KAAKqC,KAAc,UAC5F,WAEAJ,KAAKrB,MAAMG,QAAU,aAAe,gB,EAI/CuB,iBAAA,WACE,OACE,wBACE,sCACCL,KAAKM,kB,EAKZC,uBAAA,WACE,OACE,wBACE,gDACCP,KAAKM,kB,EAKZE,YAAA,WACE,IAAMvB,EAAQe,KAAKrB,MAAME,kBAAqB,YAAC,IAAD,CAAOG,IAAKgB,KAAKrB,MAAMK,IAAKC,MAAOe,KAAKrB,MAAMM,MAAOwB,MAAOT,KAAKrC,aAAkB,wBACjI,OACE,wBACE,8CACA,mBAAK+C,MAAM,iBACRzB,EACD,oBAAMyB,MAAM,UAAUV,KAAKD,WAE5BC,KAAKM,kB,EAKZA,cAAA,WACE,IAAM9B,EAAUwB,KAAKjC,KAAKC,SAAW,sBAAQ2C,QAASX,KAAKxB,SAAtB,WAAkD,GACvF,OACE,qBACGA,EACD,sBAAQmC,QAASX,KAAKvB,SAAtB,c,EAKNmC,OAAA,SAAQlD,EAAOiB,GACb,OAAKA,EAAMC,gBACND,EAAME,kBACJmB,KAAKQ,cADyBR,KAAKO,yBADPP,KAAKK,oB,qCA7ExC,OAAOL,KAAK3B,WAAWH,S,2BAIvB,OAAO8B,KAAK3B,WAAWN,U,8BAxCa8C","file":"route-remote_game.chunk.7e3f0.js","sourcesContent":["import { h, Component } from 'preact'\nimport { route } from 'preact-router'\n\nimport Board from '../components/board'\nimport ttt from '../lib/game'\nimport RemoteGameController from '../lib/remote_game_controller'\n\nexport default class RemoteGame extends Component {\n  constructor (props) {\n    super(props)\n\n    this.state = {\n      connectedToPeer: false,\n      connectedToPlayer: false,\n      waiting: true,\n      error: false,\n      win: [],\n      board: ttt.generateEmptyBoard()\n    }\n\n    if (typeof window === 'undefined') return\n\n    this.hostId = window.location.search.replace('?', '')\n\n    // TODO: what to do if there isn't a host id\n\n    this.controller = new RemoteGameController(ttt.O)\n    this.controller.on('open', () => {\n      this.setState({ connectedToPeer: true })\n      this.controller.connectToHost(this.hostId)\n    })\n    this.controller.on('connected', () => this.setState({ connectedToPlayer: true }))\n    this.controller.on('updatedGameState', (game) => {\n      const waiting = this.game.nextPlayer !== this.player\n      this.setState({\n        waiting,\n        win: game.winIndexes,\n        board: game.board\n      })\n    })\n  }\n\n  get player () {\n    return this.controller.player\n  }\n\n  get game () {\n    return this.controller.game\n  }\n\n  boardClick = (event) => {\n    console.log('BoardClick', event, this.game)\n    if (this.game.finished) return\n    if (this.game.nextPlayer !== this.player) return\n    if (!event.isEmpty) alert('This space is already taken')\n\n    this.controller.move(event.boardIndex)\n  }\n\n  restart = (event) => {\n    this.controller.restart()\n  }\n\n  newgame = (event) => {\n    route('/')\n  }\n\n  status () {\n    if (this.game && this.game.finished) {\n      if (this.game.draw) return 'Tie'\n      if ((this.player === ttt.X && this.game.xWin) || (this.player === ttt.O && this.game.oWin)) return 'You won'\n      return 'You lost'\n    } else {\n      return this.state.waiting ? 'Waiting...' : 'Your turn...'\n    }\n  }\n\n  renderConnecting () {\n    return (\n      <main>\n        <p>Connecting...</p>\n        {this.renderButtons()}\n      </main>\n    )\n  }\n\n  renderWaitingForPlayer () {\n    return (\n      <main>\n        <p>Connecting to player...</p>\n        {this.renderButtons()}\n      </main>\n    )\n  }\n\n  renderBoard () {\n    const board = this.state.connectedToPlayer ? (<Board win={this.state.win} board={this.state.board} click={this.boardClick} />) : <div />\n    return (\n      <main>\n        <p>You are playing as O.</p>\n        <div class='board-wrapper'>\n          {board}\n          <span class='status'>{this.status()}</span>\n        </div>\n        {this.renderButtons()}\n      </main>\n    )\n  }\n\n  renderButtons () {\n    const restart = this.game.finished ? <button onclick={this.restart}>Restart</button> : ''\n    return (\n      <p>\n        {restart}\n        <button onclick={this.newgame}>New Game</button>\n      </p>\n    )\n  }\n\n  render (props, state) {\n    if (!state.connectedToPeer) return this.renderConnecting()\n    if (!state.connectedToPlayer) return this.renderWaitingForPlayer()\n    return this.renderBoard()\n  }\n}\n"],"sourceRoot":""}